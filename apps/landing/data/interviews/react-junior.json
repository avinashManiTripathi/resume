{
    "slug": "react-junior-interview-questions",
    "title": "React.js Junior to Mid: The 50+ Question Masterclass (2026)",
    "description": "The ultimate technical deep-dive. 50+ architectural and trick questions covering React 19, Fiber, rendering performance, and enterprise state management patterns.",
    "heroBadge": "Masterclass Guide: 50+ Q&A",
    "sections": [
        {
            "title": "Introduction: Beyond the Basics",
            "content": "As you transition from a beginner to a Junior/Mid-level developer, your understanding must shift from **'How to use React'** to **'How React works internally'**. This guide is designed to simulate a high-level technical screening where architecture, performance, and deep JS knowledge are tested. We cover over 50 questions that dive into the guts of the library.",
            "image": "/images/interviews/react-main.png"
        },
        {
            "title": "1. Core Internals & Rendering (Fiber & Reconciliation)",
            "content": "**Q1: What is React Fiber?**\nReact Fiber is the implementation of the core reconciliation algorithm. It's essentially a reimplementation of the stack, specifically for components. It allows React to pause, resume, or restart work on different components depending on priority. This is the foundation of Concurrent React.\n\n**Q2: Explain the Reconciliation Algorithm.**\nWhen a component's state or props change, React creates a new virtual tree. It then compares (diffs) this with the old tree. Using heuristics (like keys), it identifies the minimum number of changes needed to update the real DOM.\n\n**Q3: Why are 'keys' important in lists?**\nKeys help React identify which items have changed, been added, or been removed. Without stable keys, React might re-render every item in a list unnecessarily or, worse, mix up component states (like an input value moving to a different row).\n\n**Q4: Shadow DOM vs. Virtual DOM?**\nShadow DOM is a browser technology used for encapsulation in Web Components. Virtual DOM is a software pattern implemented in React to optimize DOM updates by batching changes in an abstract tree.\n\n**Q5: What are Synthetic Events?**\nReact wraps native browser events in its own `SyntheticEvent` wrapper to ensure cross-browser consistency and for performance (event delegation). Native events are attached to the root, not individual elements."
        },
        {
            "title": "2. Data Flow & Component Architecture",
            "content": "**Q6: Props vs. State?**\nProps are read-only inputs passed from a parent to a child, used to configure the component. State is internal data managed within the component that can change over time and trigger re-renders.\n\n**Q7: Composition over Inheritance?**\nReact favors composition. Instead of extending classes, you build components by passing other components as props (like `children`) or using specialization patterns. This avoids rigid hierarchies.\n\n**Q8: Controlled vs. Uncontrolled Components?**\nControlled components have their value handled by React state (via `onChange`). Uncontrolled components rely on the DOM itself (accessed via `refs`). Controlled is the standard for most enterprise forms.\n\n**Q9: What is Prop Drilling?**\nPassing data through multiple levels of components that don't need it just to get it down to a deep child. Solve it with Context API, specialized hooks, or state management libraries.\n\n**Q10: High-Order Components (HOC) vs. Hooks?**\nHOCs are functions that take a component and return a new one (wrapping it). Hooks are functions that let you 'hook into' React state and lifecycle. Hooks have largely replaced HOCs because they avoid wrapper hell and are easier to compose."
        },
        {
            "title": "3. Hooks Mastery (The Deep Dive)",
            "content": "**Q11: The Rules of Hooks?**\n1. Only call hooks at the top level (no loops/conditions). 2. Only call hooks from React functions. This ensures the execution order remains stable across renders.\n\n**Q12: Why shouldn't you use `useState` for large objects?**\n`useState`'s setter replaces the entire state. If you update one field, you must manually spread the rest. For complex objects, `useReducer` or specialized state libraries are more readable and performant.\n\n**Q13: Explain `useEffect` dependencies.**\nReact compares the dependency array values using `Object.is`. If any value changes, the effect runs. If empty `[]`, it runs once on mount. If omitted, it runs on every render (avoid this!).\n\n**Q14: When to use `useLayoutEffect`?**\nUse it for measurements or DOM manipulations that need to happen synchronously *before* the browser paints. This prevents the 'flicker' seen with `useEffect`.\n\n**Q15: The 'Capture Value' property of renders?**\nEvery render has its own props, state, and even event handlers. If you set a timeout in a render, it will always see the state from that specific render, even if the state has updated since then (unless you use a `ref`)."
        },
        {
            "title": "4. Advanced Hooks & State Patterns",
            "content": "**Q16: `useReducer` vs. Redux?**\n`useReducer` is local to a component tree. Redux is global. `useReducer` is perfect for complex local state logic that would make `useState` messy.\n\n**Q17: How does `useContext` trigger updates?**\nWhen the Provider's `value` changes, all consumers of that context re-render. Note: This can cause performance issues if the value is a large object and changes frequently.\n\n**Q18: What is a 'State Machine' in React?**\nYou can use `useReducer` to implement finite state machines. This prevents impossible states (like being 'loading' and 'error' at the same time).\n\n**Q19: Explain `useRef` beyond DOM access.**\n`useRef` is a box for any mutable value that survives re-renders but *doesn't* trigger a re-render when it changes. Use it for timers, previous state values, or tracking mount status.\n\n**Q20: Custom Hooks: Logic vs. State?**\nA custom hook doesn't share state between components; it shares logic. Every component that calls a custom hook gets its own isolated instance of the state inside that hook."
        },
        {
            "title": "5. Performance Optimization & Memoization",
            "content": "**Q21: What is `React.memo`?**\nA higher-order component that prevents a component from re-rendering if its props haven't changed. It uses a shallow comparison by default.\n\n**Q22: `useMemo` vs. `useCallback`?**\n`useMemo` caches the **return value** of a function. `useCallback` caches the **function instance** itself. Use `useCallback` when passing functions to children wrapped in `React.memo`.\n\n**Q23: How to find performance bottlenecks?**\nUse the **React DevTools Profiler** or the Browser Performance tab. Look for 'Long Tasks' and components that re-render too often without prop changes.\n\n**Q24: What is Code Splitting?**\nBreaking your bundle into smaller chunks that load on demand (e.g., dynamic imports with `React.lazy` and `Suspense`). This drastically reduces the initial load time.\n\n**Q25: Batching updates in React 18/19?**\nReact now automatically batches state updates even inside promises, timeouts, and native events, reducing the number of renders significantly."
        },
        {
            "title": "6. Advanced Rendering (Suspense, Portals, Errors)",
            "content": "**Q26: What is React Suspense?**\nA component that lets you declaratively specify a loading state (fallback) for a component tree that is 'waiting' for something (like data fetching or lazy-loaded code).\n\n**Q27: Portals: When and Why?**\n`createPortal` lets you render a component into a different DOM subtree. Essential for Modals, Tooltips, and Popovers to avoid `z-index` and `overflow: hidden` issues.\n\n**Q28: Error Boundaries.**\nClass components that define `static getDerivedStateFromError` or `componentDidCatch`. They prevent a crash in one part of the UI from taking down the whole application.\n\n**Q29: Server Components (RSC) vs. Client Components?**\nServer components run on the server and send zero JS to the client. Client components run in the browser and handle interactivity. This is a core part of Next.js and modern React.\n\n**Q30: Hydration?**\nThe process where React 'attaches' event listeners and state to the HTML that was generated on the server (SSR). If the client render doesn't match the server HTML, you get a 'Hydration Error'."
        },
        {
            "title": "7. Side Effects & Data Fetching",
            "content": "**Q31: The 'Cleanup' function in `useEffect`.**\nAlways clean up subscriptions, interval timers, or global event listeners. If you don't, you create memory leaks as the component unmounts and remounts.\n\n**Q32: Avoiding Race Conditions in Fetch.**\nWhen multiple requests happen, the last one might finish first but get overwritten by a slower, older request. Use an `AbortController` or a boolean flag inside `useEffect` to ignore old results.\n\n**Q33: Why TanStack Query (React Query)?**\nIt handles caching, de-duplication, background syncing, and loading/error states in a robust way that `useEffect` cannot easily replicate.\n\n**Q34: How to handle global API errors?**\nUse an Axios interceptor or a wrapper around `fetch` to catch 401/500 errors globally and trigger global UI notifications (e.g., redirect to login).\n\n**Q35: Caching vs. State Management?**\nAPI data is 'server state' (cache). Global state (Zustand/Redux) should ideally be reserved for 'client state' (UI toggles, auth status, local drafts)."
        },
        {
            "title": "8. Enterprise Ecosystem & Testing",
            "content": "**Q36: Why Vitest + React Testing Library?**\nReact Testing Library encourages testing 'how the user sees it' (by text/role) rather than testing internal implementation details. Vitest is a fast, modern successor to Jest.\n\n**Q37: Mocking API calls (MSW).**\nMock Service Worker (MSW) intercepts network requests at the browser/node level, allowing you to test your real fetching logic without a backend.\n\n**Q38: Folder Structure Patterns.**\nFeature-based (by domain) vs. Layer-based (components, hooks, services). For large apps, grouping by feature (e.g., `features/authentication/`) is far more maintainable.\n\n**Q39: TSLint/ESLint for React.**\nEnsure plugins like `eslint-plugin-react-hooks` are enabled. They catch common errors like missing dependencies in `useEffect` or calling hooks conditionally.\n\n**Q40: Storybook.**\nAn isolated environment to build and document UI components. Essential for collaborative design systems and visual regression testing."
        },
        {
            "title": "9. Modern React Patterns (React 19 & Beyond)",
            "content": "**Q41: useTransition Hook.**\nLets you mark an update as a 'transition', which React can interrupt to handle more urgent tasks (like user typing). Keeps the UI responsive during heavy renders.\n\n**Q42: useDeferredValue.**\nSimilar to a debounce, but managed by React. It allows you to defer re-rendering a specifically expensive part of the UI until the main thread is clear.\n\n**Q43: The 'use' hook (React 19).**\nA new hook that can consume promises or context conditionally. It can be used inside loops and conditions, breaking the traditional Rules of Hooks.\n\n**Q44: Server Actions.**\nA new way to handle form submissions and data mutations directly from components. They bridge the gap between client forms and server functions.\n\n**Q45: Ref as a Prop (React 19).**\nYou no longer need `forwardRef` in standard cases; `ref` is now just a regular prop you can pass through components."
        },
        {
            "title": "10. Career & Architecture: The Junior-to-Mid Bridge",
            "content": "**Q46: How do you handle a large codebase?**\nRead the documentation, look at existing PRs, start with small fixes, and understand the core data flow before attempting major refactors.\n\n**Q47: Code Review Best Practices.**\nBe empathetic, focus on logic over style (let the linter handle that), and explain 'why' you are suggesting a change, not just 'what'.\n\n**Q48: What is 'Dead Code' and how to find it?**\nUnused components, imports, or state. Use tools like `knip` or ESLint to find and remove it to keep the bundle size small.\n\n**Q49: Technical Debt.**\nChoosing a quick fix over a sustainable one. It's okay occasionally, but must be documented and scheduled for a refactor to avoid slowing down future development.\n\n**Q50: Continuous Learning.**\nHow do you stay updated? Mention specific newsletters (React Status), creators, or the official React blog. Show that you are proactive about the ecosystem evolving."
        },
        {
            "title": "Summary & Next Steps",
            "content": "Mastering React is a journey of understanding abstraction. You've now seen 50 questions that cover everything from basic state to complex concurrent rendering. The next step? Build a project that intentionally breaks these limitsâ€”force it to be slow, then optimize it. That's where the real learning happens.",
            "image": "/images/interviews/react-main.png"
        }
    ]
}