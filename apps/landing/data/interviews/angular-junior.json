{
    "slug": "angular-junior-interview-questions",
    "title": "Angular Architect: 50+ Junior to Mid Interview Deep-Dives (2026)",
    "description": "Master the Angular ecosystem. 50+ deep questions on Ivy, Change Detection, RxJS pipelines, and scaling enterprise-grade SPAs with Angular 19+.",
    "heroBadge": "Enterprise Masterclass: 50+ Q&A",
    "sections": [
        {
            "title": "Introduction: Stability and Scale with Angular",
            "content": "Angular's greatest strength is its opinionated nature, which ensures consistency in massive enterprise projects. To move beyond a Junior level, you must understand the **mechanics of the framework**: how Ivy renders, how Zone.js tracks changes, and how to harness **RxJS** for complex data flows. This guide provides 50+ questions to test your architectural depth.",
            "image": "/images/interviews/angular-main.png"
        },
        {
            "title": "1. Angular Internals & Change Detection",
            "content": "**Q1: What is the Ivy Engine?**\nIvy is Angular's third-generation compilation and rendering pipeline. It produces smaller bundles (better tree-shaking) and faster compilation, and it enables features like Standalone components.\n\n**Q2: How does Change Detection work?**\nAngular uses a tree of change detectors. When an event occurs, it traverses the component tree from top to bottom, checking for changes. By default, it uses `Zone.js` to automatically detect when async events (like timeouts or clicks) finish.\n\n**Q3: Default vs. OnPush Change Detection.**\n`Default` checks every component on every change. `OnPush` only checks a component if its `@Input` reference changes or an event originates within the component. This is the #1 performance optimization in Angular.\n\n**Q4: What is Zone.js?**\nA library that creates an execution context that persists across async tasks. It 'patches' global browser APIs (like `addEventListener`) so Angular knows exactly when to trigger change detection.\n\n**Q5: AOT vs. JIT Compilation.**\nJIT (Just-In-Time) compiles in the browser at runtime. AOT (Ahead-Of-Time) compiles during the build process. AOT is the modern standard because it catches errors earlier and makes the app load faster."
        },
        {
            "title": "2. Component Lifecycle & Communication",
            "content": "**Q6: Lifecycle Hooks order.**\n1. `ngOnChanges`. 2. `ngOnInit`. 3. `ngDoCheck`. 4. `ngAfterContentInit`. 5. `ngAfterContentChecked`. 6. `ngAfterViewInit`. 7. `ngAfterViewChecked`. 8. `ngOnDestroy`.\n\n**Q7: ngOnInit vs. Constructor.**\nThe constructor is for basic class initialization (DI). `ngOnInit` is where Angular has finished setting up the component (inputs are available) and is the right place for initialization logic.\n\n**Q8: @Input() and @Output().**\n`@Input()` allows parent-to-child communication. `@Output()` uses `EventEmitter` for child-to-parent communication. This follows the unidirectional data flow pattern.\n\n**Q9: ViewChild vs. ContentChild.**\n`@ViewChild` accesses a component/template-ref within the *own* template. `@ContentChild` accesses content projected into the component via `ng-content`.\n\n**Q10: Component Styling & Encapsulation.**\nAngular provides `Emulated` (default, adds unique attributes), `None` (styles leakage), and `ShadowDom` (true browser encapsulation). Emulated is usually the best balance."
        },
        {
            "title": "3. Dependency Injection & Services",
            "content": "**Q11: What is Dependency Injection (DI)?**\nA design pattern where a class requests dependencies from external sources rather than creating them. Angular's DI system is hierarchical and highly powerful.\n\n**Q12: ProvidedIn: 'root'.**\nMaking a service available in 'root' means it's a singleton available throughout the app and allows Angular to tree-shake the service if it's never used.\n\n**Q13: Hierarchical Injectors.**\nYou can provide services at the Module, Component, or Directive level. Providing at the component level means each instance of that component gets its own instance of the service.\n\n**Q14: Injecting the 'Host' or 'Parent'.**\nUsing decorators like `@Host()`, `@Optional()`, or `@Self()` to control exactly where the DI system looks for a dependency.\n\n**Q15: InjectionTokens.**\nUsed when you need to inject something that isn't a class, like a configuration object or a string constant."
        },
        {
            "title": "4. RxJS & Reactive Programming",
            "content": "**Q16: Observable vs. Subject.**\nAn Observable is 'unicast' (one listener per execution). A Subject is 'multicast' (one execution shared with many listeners). Subjects also allow you to manually push values via `.next()`.\n\n**Q17: Cold vs. Hot Observables.**\nCold Observables start emitting data only when someone subscribes (like an HTTP call). Hot Observables are already emitting (like mouse moves), and subscribers get the current value.\n\n**Q18: switchMap vs. mergeMap vs. concatMap.**\n`switchMap`: Cancels the previous inner observable (best for search). `mergeMap`: Runs all simultaneously. `concatMap`: Runs them in order (one after another).\n\n**Q19: Handling Unsubscription.**\nFailing to unsubscribe leads to memory leaks. Use the `async` pipe in templates (recommended!), or use the `takeUntil` pattern with a Subject in the `ngOnDestroy` hook.\n\n**Q20: BehaviorSubject vs. ReplaySubject.**\n`BehaviorSubject` stores the *current* value and emits it immediately to new subscribers. `ReplaySubject` stores and re-emits a *buffer* of previous values."
        },
        {
            "title": "5. Routing & Navigation Mastery",
            "content": "**Q21: Lazy Loading.**\nLoading modules or components on demand using `loadChildren` or `loadComponent`. This is essential for keeping the initial bundle size small.\n\n**Q22: Route Guards (CanActivate, CanMatch).**\nUsed to handle authentication and authorization logic at the route level. `CanMatch` is the modern replacement for `CanLoad` in standalone apps.\n\n**Q23: Resolvers.**\nUsed to fetch data *before* a route is activated, ensuring the component doesn't render with empty or 'loading' states unnecessarily.\n\n**Q24: Router Link Active.**\nA built-in directive that applies a CSS class to a link when its route is currently active, improving UX in navigation menus.\n\n**Q25: Hash vs. Path Location Strategy.**\nPath (HTML5) is the modern standard (e.g., `/user/1`). Hash (e.g., `/#/user/1`) is a fallback for older browsers or specifically configured servers."
        },
        {
            "title": "6. Forms: Reactive vs. Template-Driven",
            "content": "**Q26: Why favor Reactive Forms?**\nThey are more predictable, easier to test, and provide better tools for complex validation and handling dynamic field additions.\n\n**Q27: FormGroup, FormControl, FormArray.**\n`FormControl` tracks an individual field. `FormGroup` groups them. `FormArray` allows you to manage a dynamic list of controls.\n\n**Q28: Custom Validators.**\nFunctions that return an error object if validation fails or `null` if it passes. They can be injected with services for async validation (e.g., checking if an email exists).\n\n**Q29: TrackBy in NgFor.**\nUsed to improve performance in lists. It tells Angular how to track unique items (e.g., by ID) so it doesn't re-render the entire list when one item changes.\n\n**Q30: Control Value Accessor.**\nAn interface that allows your custom components to work seamlessly with Angular Forms (using `ngModel` or `formControlName`)."
        },
        {
            "title": "7. Directives, Pipes & Content Projection",
            "content": "**Q31: Structural vs. Attribute Directives.**\nStructural (`*ngIf`, `*ngFor`) modify the DOM structure (add/remove elements). Attribute (`ngClass`, `ngStyle`) modify the appearance or behavior of an existing element.\n\n**Q32: Content Projection (ng-content).**\nUsing `ng-content` to project external HTML into a component. Use the `select` attribute for multi-slot projection.\n\n**Q33: Pure vs. Impure Pipes.**\nPure pipes only run when the input reference changes. Impure pipes run on every change detection cycle. Use Pure pipes (the default) for better performance.\n\n**Q34: HostBinding and HostListener.**\n`@HostBinding` allows you to set properties on the host element. `@HostListener` allow you to listen for events on the host element from within the directive/component.\n\n**Q35: TemplateRef and ViewContainerRef.**\nLower-level APIs used to programmatically create and insert components or templates into the DOM."
        },
        {
            "title": "8. Performance & Optimization",
            "content": "**Q36: Tree Shaking.**\nAngular uses static analysis to remove unused code from the final bundle. ProvidedIn: 'root' and Standalone components were designed to maximize this.\n\n**Q37: Web Workers in Angular.**\nAngular CLI makes it easy to move expensive computations out of the main thread and into a Web Worker, keeping the UI smooth.\n\n**Q38: Differential Loading.**\nGenerating two bundles: one for modern browsers (ES2015+) and one for older ones (ES5). The browser automatically downloads the most efficient one.\n\n**Q39: Angular Signals (The Future).**\nIntroduced in Angular 16. Signals provide a fine-grained way to track state changes, potentially allowing Angular to bypass Zone.js for part of the change detection process.\n\n**Q40: Optimizing Images and Fonts.**\nUsing the `NgOptimizedImage` directive (`ngSrc`) to handle lazy loading, resizing, and priority hints automatically."
        },
        {
            "title": "9. Standalone Components & Modern Architecture",
            "content": "**Q41: The 'Standalone: true' flag.**\nMead that the component doesn't need to be declared in an `NgModule`. It manages its own dependencies via the `imports` array.\n\n**Q42: Modules are Optional.**\nYou can now build an entire Angular app without a single `.module.ts` file, leading to cleaner folder structures and easier onboarding.\n\n**Q43: Function-based Interceptors.**\nModern Angular (15+) favors function-based interceptors over class-based ones, which are more lightweight and easier to configure.\n\n**Q44: Signal-based Components.**\nUsing inputs and outputs based on Signals for even better performance and reactivity in modern Angular 17+ apps.\n\n**Q45: SSR and Hydration.**\nServer-Side Rendering (using Angular Universal) sends pre-rendered HTML to the user. 'Non-destructive hydration' (Angular 16+) prevents the 'flicker' when the client-side app takes over."
        },
        {
            "title": "10. Career & Enterprise Scale",
            "content": "**Q46: Why choose Angular for Enterprise?**\nStrict structure, built-in testing, first-class TypeScript support, and a stable update cycle make it ideal for teams with hundreds of developers.\n\n**Q47: Monorepos (Nx).**\nTools like Nx are standard for large Angular projects, allowing you to share code between multiple apps and libraries efficiently.\n\n**Q48: Handling Enterprise State (NgRx).**\nWhen state logic becomes overwhelming, NgRx (Redux pattern) provides a predictable way to manage state, though it adds boilerplate.\n\n**Q49: Mental Model for Debugging.**\nAlways start with Change Detection: 'Did my data change?' then 'Did Angular see it?'. Use Augury or the 'Signals' tab in DevTools.\n\n**Q50: Vision 2026: Angular's Renaissance.**\nTalk about 'Zoneless' Angular, improved developer experience, and how Angular is becoming more lightweight while keeping its enterprise power."
        },
        {
            "title": "Summary",
            "content": "Angular is the gold standard for robust, scalable web applications. By mastering these 50 questions, you've proven you understand not just how to use the directives, but how the entire engine works under the hood. Keep building, keep testing, and stay curious as the framework evolves.",
            "image": "/images/interviews/angular-main.png"
        }
    ]
}